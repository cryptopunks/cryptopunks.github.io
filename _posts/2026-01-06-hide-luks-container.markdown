---
layout: post  
title:  "Маскируем LUKS-контейнер под бинарный мусор"
meta_description: "Учимся маскировать шифрованные LUKS-контейнеры путём отделения и сокрытия заголовка"
date: 2026-01-06
tags: luks header encryption
categories: article  
author: "soko1"  
---

Про создание LUKS-контейнера я [уже когда-то рассказывал](https://cryptopunks.org/article/awesome+truecrypt+alternative+for+linux/). Тогда предлагалось «замаскировать» его под видеоклип, просто поменяв расширение файла, но это помогло бы тебе лишь при визуальном осмотре. При тщательном анализе (например, криминалистическим ПО, которое сортирует файлы по магическим числам и метаданным) такой файл, напротив, привлечёт к тебе лишнее внимание. 

Сегодня ты научишься отделять содержимое LUKS-раздела от его заголовка. Это позволит создать ситуацию, когда основной файл с данными выглядит для системы как абсолютно случайный бинарный шум, не имеющий структуры.

## Процесс создания контейнера с отдельным заголовком 

Первое, с чем тебе необходимо определиться, — это размер контейнера.

**Техническое замечание:** Чтобы файл реально выглядел как мусор, его нужно заполнить случайными данными. Если используешь `fallocate`, файл будет забит нулями, и область шифрования внутри него будет легко обнаружить с помощью анализа энтропии.

Давай создадим файл размером 1Гб, заполненный случайными числами и дадим ему какое-нибудь неподозрительное название:

```bash
# dd if=/dev/urandom of=~/temp_blob bs=1M count=1024
```

Далее инициализируй LUKS-контейнер, используя ключевую опцию `--header` (вынос заголовка в отдельный файл):

```bash
# cryptsetup luksFormat --header /tmp/head.file ~/temp_blob
```

Теперь расшифруй контейнер, создай на нём файловую систему и закрой его:

```bash
# cryptsetup luksOpen --header /tmp/head.file ~/temp_blob my_container
# mkfs.ext4 /dev/mapper/my_container
# cryptsetup luksClose my_container
```

## Как это работает

`head.file` — это «мозги» твоего контейнера (заголовок), а `temp_blob` — «тело» (данные). Без заголовка данные в `temp_blob` превращаются для любого наблюдателя в математически неразличимый шум. 

Давай посмотрим, что скажет утилита `file` об этих объектах:

```bash
$ file /tmp/head.file
head.file: LUKS encrypted file, ver 2, header size 16384...

$ file ~/temp_blob
temp_blob: data
```

А теперь обрати внимание на их размеры:

```bash
$ ls -lh /tmp/head.file
-rw------- 1 root root 16M Jan  4 18:04 head.file
$ ls -lh ~/temp_blob
-rw-r--r-- 1 root root 1.0G Jan  4 18:03 temp_blob
```

Как видишь, `head.file` занимает всего 16 мегабайт и однозначно определяется как заголовок какого-то криптоконтейнера, но какого именно — известно только тебе. Файл `head.file` нужно сохранить в надёжном месте и по возможности на компьютере не хранить, чтобы не привлекать лишнего внимания. 

Сохрани его, например, в каком нибудь облаке, а с компьютера удали:

```bash
# shred -u /tmp/head.file
```

Файл `temp_blob` при этом выглядит как обычный бинарный файл, который не вызовет подозрений у автоматизированных систем, так как у него отсутствуют сигнатуры. Поэтому его можно хранить где угодно. Хоть на общедоступном файловом сервере у всех на виду. 


## Алгоритм использования

Получаешь заголовок (скачиваешь из своего защищенного источника) и кладёшь его, например, в `/tmp/head.file`.
Открываешь контейнер:

```bash
# cryptsetup luksOpen --header /tmp/head.file ~/temp_blob my_container
# mount /dev/mapper/my_container /mnt
```

После работы размонтируй ФС, закрой контейнер и уничтожь заголовок:

```bash
# umount /mnt
# cryptsetup luksClose my_container
# shred -u /tmp/head.file
```

## О чём тебе важно помнить

* **Следы в браузере:** История загрузок может выдать факт скачивания файла заголовка. Используй `wget`, `curl`, или режим инкогнито в браузере.
* **История shell:** Отключи сохранение истории команд (`set +o history`), чтобы команды с путями к контейнеру не остались в системе.
* **Автоматизации** Не используй никакие скрипты и алиасы в шеллах, чтобы упростить работу с контейнером, вводи все команды вручную.
* **Использование tmpfs:** Крайне рекомендую тебе монтировать `/tmp` в оперативную память (`tmpfs`). В этом случае при перезагрузке заголовок исчезнет физически, даже если ты забудешь сделать `shred`.
* **SSD и shred:** На современных SSD команда `shred` не гарантирует полного удаления данных. Хранение заголовка на USB-флешке или внутри другого зашифрованного раздела — более надежный вариант.
* **Swap-раздел/файл** Я бы рекомендовал отключить Swap в системе, чтобы после перезагрузки из него нельзя было ничего извлечь.
* **Утечки данных:** Помни, что ОС и софт могут создавать временные файлы или дампы памяти, содержащие данные, которые ты открывал внутри своего «невидимого» контейнера.
