---
layout: post  
title:  "Шифруем данные в git-репозитории"  
meta_description: "Осваиваем инструмент git-crypt для шифрования файлов (всех, либо выборочно) в репозитории git на удаленном сервере"  
date: 2026-01-03  
tags: gpg git-crypt git github
categories: article  
author: "soko1"  
---


Где хранить важную текстовую информацию, которая постоянно изменяется, чтобы была возможность откатиться назад в случае ошибки, или чтобы была история всех изменений? Ответ очевиден - в Git! 

Но что делать, если обычного приватного репозитория на чужом сервере тебе не достаточно для хранения критической информации? Тут на подмогу приходит инструмент git-crypt.

**git-crypt** — это расширение для Git, позволяющее прозрачно шифровать файлы в репозитории с помощью GPG. С его помощью ты можешь хранить секретные данные в открытых репозиториях: на сервер файлы улетают в зашифрованном виде, в то время как локальная работа с ними остается привычной и бесшовной. 

Шифровать можно как определённые файлы (например, конфиги с чувствительными данными), различные типы файлов, так и все файлы целиком.

### Первичная подготовка системы

Естественно, сначала необходимо установить инструмент git-crypt на локальной машине. Вот [вот тут](https://github.com/AGWA/git-crypt/blob/master/INSTALL.md) можно почитать как это сделать на твоей ОС.

В линуксе обычно установка производится командами `apt install git-crypt`, или `dnf install git-crypt`, на MacOS ставится через brew `brew install git-crypt`, либо можно собрать инструмент из исходников непосредственно с git-репозитория проекта.

## Подготовка репозитория

Сначала создаём обычный git-репозиторий:

```
mkdir repo && cd repo
git init
```

Теперь нужно выбрать стратегию управления доступом. У git-crypt есть два основных пути: использование **симметричного ключа** (один файл на всех) или **GPG-ключей** (асимметричное шифрование). Давай рассмотрим оба варианта.

### Вариант 1: симметричный ключ (простой метод)

Создается единый файл-ключ без парольной фразы, который шифрует данные. 

**Плюсы:**

- Максимально быстрая настройка;
- Не нужно разбираться в инфраструктуре GPG.

**Минусы:**

- **Безопасность хранения:** Приватный ключ хранится без пароля. Если файл ключа утечет, данные будут скомпрометированы.
- **Трудности масштабирования:** Если нужно отозвать доступ у одного человека, придется перешифровывать весь репозиторий новым ключом

#### Создание и экспорт ключа

```
git-crypt init
git-crypt export-key secret_key 
```

Сохрани `secret_key` в надёжном месте! 

### Вариант 2: использование GPG (более гибкий метод)

Более гибкий и безопасный подход, особенно для командной разработки. Здесь ты используешь существующие или новые GPG-пары публичный/приватный ключ.

**Плюсы:**

- **Безопасность:** твои ключи могут быть защищены парольной фразой (passphrase) + ты сам выбираешь размер и тип ключа (при генерации).
- **Удобство:** Легко добавлять новых участников, просто импортируя их публичные ключи. Точно так же с и отзывом неактуальных ключей.

**Минусы:**

- Требует понимания работы GPG.

#### Импортирование ключа

Смотрим свой **USER_ID** через `gpg --list-keys` и далее вводим:

```
git-crypt init 
git-crypt add-gpg-user USER_ID
```

После чего в репу добавится твой публичный ключ, которым будут шифроваться данные:

```
 create mode 100644 .git-crypt/.gitattributes
 create mode 100644 .git-crypt/keys/default/0/182495E56118A1EA4ED2D74A05CBEE7369EAD565.gpg
```

## Настройка объектов шифрования

Теперь давай определимся с тем что будем шифровать. 

#### Шифруем выборочные файлы

Создаём файл `.gitattributes`:

```
wp-config.php filter=git-crypt diff=git-crypt
*.env filter=git-crypt diff=git-crypt
/certs/* filter=git-crypt diff=git-crypt
```

После коммита будет зашифрован файл `wp-config.php`, все файлы с расширением `.env` и все файлы в директории `/certs/`.

#### Шифруем все файлы в репозитории

Создаём файл `.gitattributes`:

```
** filter=git-crypt diff=git-crypt
.gitattributes !filter !diff
.gitignore !filter !diff
```

При такой настройке абсолютно все файлы в репозитории (кроме `.gitattributes` и `.gitignore`) будут зашифрованы.

### Окончательные шаги для обеих вариантов

Добавляем файл в репу и коммитим изменения:

```
git add .gitattributes
git commit -a -m "add .gitattributes"
git push 
```


Всё, теперь любые изменения в указанных файлах будут автоматически шифроваться перед отправкой на удалённый сервер.

### Импортирование зашифрованного репозитория

Если вдруг понадобится развернуть уже существующее окружение на новой машине, то выполняем следующие шаги:

Клонируем репу:

```
git clone _URL_ repo
cd repo
```

### Если использовался симметричный ключ

Импортируем ключ, предварительно скопировав его во временное хранилище (например, `/tmp/secret_key`):

```
git unlock /tmp/secret_key
```

После чего не забываем уничтожить:

```
shred -u /tmp/secret_key
```

### Если использовался GPG-ключ 

Просто вводим комманду:

```
git-crypt unlock
```

После чего вводим пароль от секретного GPG-ключа.

## О чём ещё следует помнить

* Если ты шифруешь данные существующими GPG-ключами, то они оставляют за собой следы (отпечатки) и по ним можно определить, что данные принадлежат тебе. Поэтому если тебе нужна анонимность, то генерируй новую пару ключей и используй их единоразово для каждого отдельного репозитория.
* Перед тем как слать важные данные в репозиторий - добавь тестовый файл  и убедись что он зашифрован: либо склонируй без импорта ключа и посмотри что там бинарный нечитабельный мусор, либо зайди через веб-интерфейс (если он есть). Все файлы должны определяться как бинарные.
* Если устройство слабое, а репозиторий очень большой, то расшифровка файлов может занять много времени. Особенно это ощущается при первоначальном импорте ключей, поэтому не торопись отменять операцию, а просто подожди.
* Не забывай про бэкапы ключей! Создавай их в очень надёжном месте, например, в keepassxc. 
