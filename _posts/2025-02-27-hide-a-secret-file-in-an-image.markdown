---
layout: post  
title:  "Прячем секретный файл в картинку/фильм"  
meta_description: "Замаскируем GPG-файл внутри картинки с использованием cat/dd/ls"  
date: 2025-02-27  
tags: steganography gpg
categories: article  
author: "soko1"  
---

У шифрованной информации есть несколько минусов - тебя могут вынудить назвать пароль/ключ для ее дешифровки, либо этими файлами можно привлечь внимание преступника, который эти данные каким-то образом у тебя украл. И он будет пытаться эти данные расшифровать.

Стеганография решает эту проблему, потому что шифрованный файл можно спрятать внутри другого, совершенно неприметного файла. Чем мы сегодня и займёся. Я научу тебя делать это тремя командами, которые есть в совершенно любой Unix-системе (в том числе в MacOS и даже Windows). Но это будет один из самых простых и примитивных способов. Стеганография куда более сложная наука и для нее существует огромное кол-во инструментов для еще большей маскировки.

## Немного теории

Начало файла начинается с его заголовока, который содержит метаданные. Эти метаданные описывают его тип, адреса c которых начинаются данные и другие характеристики. Этих характеристик много и они зависят от типа файлов. 

Просмотреть тип файла можно утилитой **file**:

```
$ file 1.jpg
1.jpg: JPEG image data, Exif standard: [TIFF image data, big-endian, direntries=11, manufacturer=NIKON CORPORATION, model=NIKON D3100, orientation=upper-left, xresolution=180, yresolution=188, resolutionunit=2, software=Ver.1.01 , datetime=2025:01:26 16:28:02, GPS-Data], baseline, precision 8, 4608x3072, components 3
```

По сути, заголовок выполняет функцию, аналогичную расширению файла, но содержит более сложную и детализированную информацию, что позволяет более точно управлять данными. Ну и если поменять расширение у файла, то его заголовок никак не изменится. 

Прибегая к стеганографии мы научимся дописывать один файл в конец другого. Таким образом целостность сохранится, но в тоже время, если знать что в нём вшит другой файл, то его можно довольно легко извлечь зная изначальные размеры этих файлов.

## Маскируем шифрованный GPG файл под файл JPEG

Предположим у тебя есть файл **secret.gpg** и ты хочешь спрятать его внутри картинки **image.jpg**.

Первое что необходимо сделать - определить размеры обоих файлов и где нибудь их записать:

```
$ ls -l image.jpg secret.gpg
-rw-r--r--@ 1 user  user  9880935 Feb 27 21:22 image.jpg
-rw-r--r--  1 user  user  2981978 Feb 27 22:53 secret.gpg
```

**9880935** - это размер в байтах файла image.jpg, соответственно **2981978** - secret.gpg

Теперь запрячем файл secret.gpg в конец image.jpg:

```
$ cat secret.gpg >>image.jpg
```

Открой файл image.jpg и убедись что картинка открывается как и ранее, только ее размер увеличился на размер байт файла secret.gpg:

```
ls -l image.jpg
-rw-r--r--@ 1 user  user  12862913 Feb 27 22:57 image.jpg
```

Считаем: 9880935 (image.jpg) + 2981978 (secret.gpg) = 12862913 байт

Заодно можем повторно проверить тип файла и убедиться что он не изменился:

```
$ file image.jpg
image.jpg: JPEG image data, Exif standard: [TIFF image data, big-endian, direntries=11, manufacturer=NIKON CORPORATION, model=NIKON D3100, orientation=upper-left, xresolution=180, yresolution=188, resolutionunit=2, software=Ver.1.01 , datetime=2025:01:26 16:28:02, GPS-Data], baseline, precision 8, 4608x3072, components 3
```

## Извлекаем из картинки зашифрованный gpg-файл

Для этого необходимо использовать утилиту **dd**:

```
dd if=image.jpg of=secret_new.gpg bs=1 count=2981978 skip=9880935
```

Тут **count** это размер в байтах извлекаемого файла (secret.gpg), а **skip** (пропустить кол-во байт) - размер нашей картинки **до ее модификации**.

В аргументе **if** указывается исходный файл, а в **of** файл, который создасться после выполнения этой команды.

Давай убедимся что новый файл создался без ошибок:

```
$ ls -l secret_new.gpg && file secret_new.gpg
-rw-r--r--  1 user  user  2981978 Feb 27 23:04 secret_new.gpg
secret_new.gpg: PGP symmetric key encrypted data - AES with 256-bit key salted & iterated - SHA256 .
```

Как видишь файлы secret.gpg и secret_new.gpg идеинтичны.

### Несколько важных моментов

* Учитывай что такого рода картинки нельзя загружать на сервисы, которые как-либо сжимают файлы, иначе ты потеряешь свои данные.

* Всегда перед экспериментами делай бэкапы файлов, потому что что нибудь может пойти не так. В том числе не забывай записывать размеры файлов до их слияния где нибудь, иначе не сможешь восстановить файл. На самом деле сможешь, но этот процесс не обойдётся без какого-нибудь HEX-редактора (в нем потребуется определить адрес начала заголовка второго файла и конца файла).

* Не спались на размере файла. Выбирай форматы и файлы в соответствии с объемом файла, который хочешь запрятать. Например, если тебе необходимо спрятать шифрованный LUKS-контейнер объемом 5Gb, то JPEG-файл естественно для этого рассматривать не стоит. Попробуй дописать его в какой нибудь фильм хорошего качества, например. 

* Учти что не со всеми типами файлов такой трюк работает (например, с docx у меня не сработало). Файл то всегда допишется в конец, но исходный файл может уже не открыться после этого. Некоторые форматы файлов и программы очень придирчивы к лишнему содержанию и проверяют контрольные суммы.

* Все важные файлы перед маскировкой обязательно шифруй (например, с помощью инструмента GnuPG), особенно это актуально для файлов, которые ты собираешься публиковать в интернете (неплохая идея для бэкапа).

* Дозапись файла не самый лучший вариант стеганографии и он довольно легко определяется специальными инструментами, поэтому если нужна хорошая защита, то имеет смысл рассмотреть какой-нибудь более сложный метод скрытия.
